type: edu
files:
- name: build.gradle
  visible: true
  text: |-
    buildscript {
        repositories {
            mavenCentral()
        }
        dependencies {
            classpath "org.jetbrains.kotlin:kotlin-serialization:1.6.21"
        }
    }
    def ktor_version = "1.6.7"

    apply plugin: 'java'
    apply plugin: 'org.jetbrains.kotlin.jvm'
    apply plugin: 'kotlin'
    apply plugin: 'kotlinx-serialization'

    repositories {
        mavenCentral()
    }


    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation "org.jetbrains.kotlin:kotlin-stdlib"
        implementation "io.ktor:ktor-server-core:$ktor_version"
        implementation "io.ktor:ktor-server-netty:$ktor_version"
        implementation("ch.qos.logback:logback-classic:1.2.10")

        implementation "io.ktor:ktor-serialization:$ktor_version"
        implementation('org.jetbrains.exposed:exposed-core:0.37.3')
        implementation('org.jetbrains.exposed:exposed-dao:0.37.3')
        implementation('org.jetbrains.exposed:exposed-jdbc:0.37.3')
        implementation('com.zaxxer:HikariCP:5.0.1')
        implementation("org.postgresql:postgresql:42.3.2")
    }
  learner_created: false
- name: src/resources/application.conf
  visible: true
  text: |-
    ktor {
        deployment {
            port = 28888
        }
        application {
            modules = [hotkitchen.ApplicationKt.module]
        }
    }
  learner_created: false
- name: src/Application.kt
  visible: true
  text: |-
    package hotkitchen

    import io.ktor.application.*

    fun main(args: Array<String>): Unit = io.ktor.server.netty.EngineMain.main(args)

    fun Application.module(testing: Boolean = false) {}
  learner_created: false
- name: test/HotKitchenTest.kt
  visible: false
  text: |-
    import com.typesafe.config.ConfigFactory
    import io.ktor.config.*
    import io.ktor.http.*
    import io.ktor.server.testing.*
    import kotlinx.serialization.decodeFromString
    import kotlinx.serialization.encodeToString
    import kotlinx.serialization.json.Json
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import testdata.*

    class HotKitchenTest : StageTest<Any>() {

        private val time = System.currentTimeMillis()
        private val jwtRegex = """^[a-zA-Z0-9]+?\.[a-zA-Z0-9]+?\..+""".toRegex()
        private val currentCredentialsClient = Credentials("$time@client.com", "client", "password$time")
        private var currentUserClient = User(
            time.toString() + "name",
            "client",
            "+79999999999",
            currentCredentialsClient.email,
            time.toString() + "address"
        )
        private val currentCredentialsStaff = Credentials("$time@staff.com", "staff", "password$time")
        private val currentMeals = arrayOf(
            Meal(
                time.toInt(),
                "$time title1",
                (time.toInt() % 100).toFloat(),
                "image $time url",
                listOf((0..10).random(), (0..10).random(), (0..10).random())
            ),
            Meal(
                time.toInt() + 1,
                "$time title1",
                (time.toInt() % 100).toFloat(),
                "image $time url",
                listOf((0..10).random(), (0..10).random(), (0..10).random())
            ),
            Meal(
                time.toInt() + 2,
                "$time title1",
                (time.toInt() % 100).toFloat(),
                "image $time url",
                listOf((0..10).random(), (0..10).random(), (0..10).random())
            )
        )
        private val accessDenied = """{"status":"Access denied"}"""

        private val price = currentMeals[0].price + currentMeals[1].price + currentMeals[2].price
        private val mealsIds = listOf(currentMeals[0].mealId, currentMeals[1].mealId, currentMeals[2].mealId)
        private val currentOrder =
            Order(time.toInt(), currentCredentialsClient.email, mealsIds, price, currentUserClient.address, "COOK")

        private lateinit var signInTokenClient: String
        private lateinit var signInTokenStaff: String

        private var incompleteSize = 0


        @DynamicTest(order = 1)
        fun getSignInJWTToken(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentialsClient))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                try {
                    val principal = Json.decodeFromString<Token>(response.content ?: "")
                    signInTokenClient = principal.token
                    if (!signInTokenClient.matches(jwtRegex) || signInTokenClient.contains(currentCredentialsClient.email))
                        return@withApplication CheckResult.wrong("Invalid JWT token")
                } catch (e: Exception) {
                    return@withApplication CheckResult.wrong("Cannot get token form /signin request")
                }
            }
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentialsStaff))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                try {
                    val principal = Json.decodeFromString<Token>(response.content ?: "")
                    signInTokenStaff = principal.token
                    if (!signInTokenStaff.matches(jwtRegex) || signInTokenStaff.contains(currentCredentialsStaff.email))
                        return@withApplication CheckResult.wrong("Invalid JWT token")
                } catch (e: Exception) {
                    return@withApplication CheckResult.wrong("Cannot get token form /signin request")
                }
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 2)
        fun correctValidation(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/validate") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.status() != HttpStatusCode.OK || response.content != "Hello, ${currentCredentialsClient.userType} ${currentCredentialsClient.email}") return@withApplication CheckResult.wrong(
                    "testdata.Token validation with signin token failed.\nStatus code should be \"200 OK\"\nMessage should be \"Hello, ${currentCredentialsClient.userType} ${currentCredentialsClient.email}\""
                )
            }
            with(handleRequest(HttpMethod.Get, "/validate") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
            }) {
                if (response.status() != HttpStatusCode.OK || response.content != "Hello, ${currentCredentialsStaff.userType} ${currentCredentialsStaff.email}") return@withApplication CheckResult.wrong(
                    "testdata.Token validation with signin token failed.\nStatus code should be \"200 OK\"\nMessage should be \"Hello, ${currentCredentialsStaff.userType} ${currentCredentialsStaff.email}\""
                )
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 3)
        fun createUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Put, "/me") {
                setBody(Json.encodeToString(currentUserClient))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Cannot add user by put method")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 4)
        fun successAdditionMeal(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            for (meal in currentMeals)
                with(handleRequest(HttpMethod.Post, "/meals") {
                    setBody(Json.encodeToString(meal))
                    addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                    addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                }) {
                    if (response.status() != HttpStatusCode.OK)
                        return@withApplication CheckResult.wrong("The meal was not added. Wrong status code.")
                }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 5)
        fun invalidOrderCreation(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/order") {
                setBody(Json.encodeToString(listOf(1, 2, (-9999999..-9999).random())))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("Created an order with the wrong meal id. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 6)
        fun validOrderCreation(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/order") {
                setBody(Json.encodeToString(mealsIds))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Unable to create order. Wrong status code.")
                val order = Json.decodeFromString<Order>(response.content ?: "")
                if (order.userEmail != currentOrder.userEmail || order.price != currentOrder.price || order.address != currentOrder.address || order.status != currentOrder.status)
                    return@withApplication CheckResult.wrong("Wrong order.")
                else currentOrder.orderId = order.orderId
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 7)
        fun invalidMarkAsReady(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/order/${currentOrder.orderId}/markReady") {
                setBody(Json.encodeToString(mealsIds))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.status() != HttpStatusCode.Forbidden || response.content != accessDenied)
                    return@withApplication CheckResult.wrong("Only staff can mark order as COMPLETE. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 8)
        fun validMarkAsReady(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/order/${currentOrder.orderId}/markReady") {
                setBody(Json.encodeToString(mealsIds))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Unable to mark order as COMPLETE. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 9)
        fun getOrders(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/orderHistory") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                val orders: List<Order> = Json.decodeFromString(response.content ?: "")
                var flag = true
                for (order in orders) {
                    if (order.status == "COOK") incompleteSize++
                    if (order.orderId == currentOrder.orderId) flag = false
                }
                if (flag)
                    return@withApplication CheckResult.wrong("Wrong orders list. The newly added order is missing.")
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Wrong status code in /orderHistory")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 10)
        fun getIncompleteOrders(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/orderIncomplete") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                val orders: List<Order> = Json.decodeFromString(response.content ?: "")
                for (order in orders)
                    if (order.status != "COOK") return@withApplication CheckResult.wrong("One of the orders is COMPLETE.")
                if (orders.size != incompleteSize) return@withApplication CheckResult.wrong("Invalid size of Incomplete orders.")
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Wrong status code in /orderHistory")
            }
            return@withApplication CheckResult.correct()
        }

    }
  learner_created: false
- name: src/presentation/routing/responseDto/GetMealResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.Meal
    import kotlinx.serialization.Serializable

    @Serializable
    data class GetMealResponse (
        val mealId: Int,
        val title: String,
        val price: Double,
        val imageUrl: String,
        val categoryIds: List<Int>
    ): ApiResponse {
        companion object {
            fun fromMeal(meal: Meal): GetMealResponse {
                return GetMealResponse(
                     mealId = meal.mealId,
                     title = meal.title,
                     price = meal.price,
                     imageUrl = meal.imageUrl,
                     categoryIds = meal.categoryIds
                )
            }
        }
    }
  learner_created: true
- name: src/presentation/routing/AuthRouting.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing

    import hotkitchen.domain.service.UserCredentialsService
    import hotkitchen.domain.service.tokenService.jwtToken.JwtTokenService
    import hotkitchen.presentation.routing.requestDto.SignInRequest
    import hotkitchen.presentation.routing.requestDto.SignUpRequest
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*
    import io.ktor.http.*
    import io.ktor.request.*
    import io.ktor.response.*
    import io.ktor.routing.*

    object AuthRouting {

        fun Routing.authRouting(userCredentialsService: UserCredentialsService, tokenService: JwtTokenService) {
            post("/signup") {
                val signupRequest = call.receive<SignUpRequest>()
                println("requestBody $signupRequest")

                val response = userCredentialsService.signUpUser(signupRequest)
                call.respond(HttpStatusCode.OK, response)
            }

            post("/signin") {
                val signinRequest = call.receive<SignInRequest>()
                println("requestBody $signinRequest")

                val response = userCredentialsService.signInUser(signinRequest)
                call.respond(HttpStatusCode.OK, response)
            }

            authenticate(tokenService.appScope) {
                get("/validate") {
                    println("headers ${call.request.headers}")

                    val principal: JWTPrincipal = call.principal<JWTPrincipal>()!!

                    val email = principal["email"]!!
                    val userType = principal["userType"]!!

                    call.respond(HttpStatusCode.OK, "Hello, $userType $email")
                }
            }
        }
    }
  learner_created: true
- name: src/util/Validation.kt
  visible: true
  text: |-
    package hotkitchen.util

    object Validation {

        fun String.isNotValidEmail(): Boolean {
            return "(\\w+[\\w.\\-])*\\w+@([A-Za-z0-9]+\\.)+[A-Za-z]{2,}".toRegex().matches(this).not()
        }

        fun String.isNotValidPass(): Boolean {
            return length < 6 || containsNoDigits() || containsNoLetter()
        }

        private fun String.containsNoDigits(): Boolean {
            return firstOrNull(Char::isDigit) == null
        }

        private fun String.containsNoLetter(): Boolean {
            return firstOrNull(Char::isLetter) == null
        }
    }
  learner_created: true
- name: src/presentation/routing/requestDto/AddMealRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import kotlinx.serialization.Serializable

    @Serializable
    data class AddMealRequest(
        val mealId: String,
        val title: String,
        val price: Double,
        val imageUrl: String,
        val categoryIds: List<Int>
    )
  learner_created: true
- name: src/presentation/routing/responseDto/ApiResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    interface ApiResponse
  learner_created: true
- name: src/domain/exception/SignupExistingUserException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SignupExistingUserException(
        override val message: String = "There is already an user with that email registered"): Exception(message)
  learner_created: true
- name: src/domain/exception/DeniedAccessException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class DeniedAccessException(
        override val message: String = "Access denied"): Exception(message)
  learner_created: true
- name: src/data/repository/database/InMemoryUserCredentialsDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database

    import hotkitchen.domain.model.User

    object InMemoryUserCredentialsDatabase: UserCredentialsDatabase {

        private val database: MutableList<User> = mutableListOf()

        override fun userByEmail(email: String): User? {
            return database.firstOrNull { it.email == email }
        }

        override fun addUser(email: String, type: User.Type, password: String): User? {
            val user = User(email, type, password)
            database.add(user)
            return user
        }
    }
  learner_created: true
- name: src/util/Extensions.kt
  visible: true
  text: |-
    package hotkitchen.util

    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*

    object Extensions {

        fun ApplicationCall.getClaims(vararg name: String): List<String> {
            val jwtPrincipal = this.principal<JWTPrincipal>()!!

            return name.map {
                jwtPrincipal[it]!!
            }
        }
    }
  learner_created: true
- name: src/Controller.kt
  visible: true
  text: |-
    package hotkitchen

    import hotkitchen.domain.service.MealService
    import hotkitchen.domain.service.UserInfoService
    import hotkitchen.domain.service.UserCredentialsService
    import hotkitchen.domain.service.tokenService.jwtToken.JwtTokenService
    import hotkitchen.presentation.routing.AuthRouting.authRouting
    import hotkitchen.presentation.routing.ErrorRouting.errorRouting
    import hotkitchen.presentation.routing.MealRouting.mealRouting
    import hotkitchen.presentation.routing.UserInfoRouting.userInfoRouting
    import hotkitchen.util.CustomLoggerPlugin
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.features.*
    import io.ktor.routing.*
    import io.ktor.serialization.*


    object Controller {
        fun Application.controller(
            userCredentialsService: UserCredentialsService,
            userInfoService: UserInfoService,
            tokenService: JwtTokenService,
            mealService: MealService,
            testing: Boolean,
        ) {

            install(ContentNegotiation) { json() }

            install(CustomLoggerPlugin)

            install(StatusPages){ errorRouting() }

            install(Authentication, tokenService.authConfig)

            install(Routing) {
    //        trace {
    //            //application.log.trace(it.buildText())
    //            println(it.buildText())
    //        }
                authRouting(userCredentialsService, tokenService)
                userInfoRouting(userInfoService, tokenService)
                mealRouting(mealService)
            }
        }
    }
  learner_created: true
- name: src/data/repository/database/UserCredentialsDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database

    import hotkitchen.domain.model.User

    interface UserCredentialsDatabase {
        fun userByEmail(email: String): User?
        fun addUser(email: String, type: User.Type, password: String): User?
    }
  learner_created: true
- name: src/data/repository/database/exposed/entity/CategoryEntity.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.entity

    import hotkitchen.data.repository.database.exposed.table.CategoryTable
    import hotkitchen.domain.model.Category
    import org.jetbrains.exposed.dao.IntEntity
    import org.jetbrains.exposed.dao.IntEntityClass
    import org.jetbrains.exposed.dao.id.EntityID

    class CategoryEntity(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<CategoryEntity>(CategoryTable)

        var title: String by CategoryTable.title
        var description: String by CategoryTable.description

        fun toCategory(): Category {
            return Category(
                categoryId = id.value,
                title = title,
                description = description
            )
        }
    }
  learner_created: true
- name: src/domain/exception/InvalidMealIdException.kt
  visible: true
  text: |
    package hotkitchen.domain.exception

    class InvalidMealIdException(
        override val message: String = "Invalid mealId, mealId should be an integer number"): Exception(message) {
    }
  learner_created: true
- name: src/domain/exception/SignupInvalidEmailException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SignupInvalidEmailException(
        override val message: String =
            "A valid email address consists of an email prefix and an email domain, both in acceptable formats. " +
                    "Use only letters, numbers, and special symbols:"
    ): Exception(message)
  learner_created: true
- name: src/presentation/routing/responseDto/AddMealResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.Meal
    import kotlinx.serialization.Serializable

    @Serializable
    data class AddMealResponse(val meal: Meal) : ApiResponse
  learner_created: true
- name: src/domain/service/tokenService/TokenService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service.tokenService

    import hotkitchen.domain.model.User

    interface TokenService {

        fun isValidToken(tokenString: String): Boolean

        fun produceToken(userType: User.Type, email: String): String

        fun decodeToken(tokenString: String): Pair<String, String>
    }
  learner_created: true
- name: src/domain/model/Category.kt
  visible: true
  text: |-
    package hotkitchen.domain.model

    import kotlinx.serialization.Serializable

    @Serializable
    data class Category (
        val categoryId: Int,
        val title: String,
        val description: String
    )
  learner_created: true
- name: src/domain/exception/SignupInvalidPasswordException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SignupInvalidPasswordException(
        override val message: String =
            "A valid password is a password that is at least six characters long and consists of letters and numbers"
    ): Exception(message)
  learner_created: true
- name: src/data/repository/database/UserInfoDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database

    import hotkitchen.domain.model.UserInfo

    interface UserInfoDatabase {
        fun userInfoByEmail(email: String): UserInfo?
        fun updateOrCreateUserInfo(name: String, userType: String?, phone: String, email: String, address: String): UserInfo?
        fun deleteUser(email: String)
    }
  learner_created: true
- name: src/util/CustomLoggerPlugin.kt
  visible: true
  text: |-
    package hotkitchen.util

    import io.ktor.application.*
    import io.ktor.features.*
    import io.ktor.response.*
    import io.ktor.util.*

    class CustomLoggerPlugin {

        class Configuration

        companion object Plugin : ApplicationFeature<ApplicationCallPipeline, Configuration, CustomLoggerPlugin> {
            override val key = AttributeKey<CustomLoggerPlugin>("CustomLoggerPlugin")
            override fun install(pipeline: ApplicationCallPipeline, configure: Configuration.() -> Unit): CustomLoggerPlugin {
                val plugin = CustomLoggerPlugin()

                pipeline.intercept(ApplicationCallPipeline.Monitoring) { data ->
                    println("call: ${context.request.toLogString()}")
                    proceedWith(subject)
                }

                pipeline.sendPipeline.intercept(ApplicationSendPipeline.Transform) { data ->
                    val dataString = if(data is Unit) "" else ", $data"
                    println("response: ${call.response.status() ?: ""}$dataString")
                    proceedWith(subject)
                }

                return plugin
            }
        }
    }
  learner_created: true
- name: src/domain/service/tokenService/custom/CustomTokenService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service.tokenService.custom

    import hotkitchen.domain.model.User
    import hotkitchen.domain.service.tokenService.TokenService

    class CustomTokenService: TokenService {

        override fun isValidToken(tokenString: String): Boolean {
            return tokenString.startsWith("abc.")
        }

        override fun produceToken(userType: User.Type, email: String): String {
            return "abc.${userType.typeString}.${email.replace('.', '*')}"
        }

        override fun decodeToken(tokenString: String): Pair<String, String>{
            val (userType, email) = "^abc\\.(.*)\\.(.*)$".toRegex()
                .matchEntire(tokenString)!!.destructured
            return userType to email.replace('*', '.')
        }
    }
  learner_created: true
- name: src/domain/exception/DatabaseException.kt
  visible: true
  text: |
    package hotkitchen.domain.exception

    class DatabaseException(
        override val message: String = "Database failed") : Exception(message)
  learner_created: true
- name: src/data/repository/database/MealDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database

    import hotkitchen.domain.model.Category
    import hotkitchen.domain.model.Meal

    interface MealDatabase {
        fun addMeal(mealId: Int, title: String, price: Double, imageUrl: String, categoryIds: List<Int>): Meal?
        fun getMeal(mealId: Int): Meal?
        fun addCategory(categoryId: Int, title: String, description: String): Category?
        fun getCategory(categoryId: Int): Category?
        fun getMealList(): List<Meal>
        fun getCategoryList(): List<Category>
    }
  learner_created: true
- name: src/domain/exception/InvalidUserInfoRequest.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class InvalidUserInfoRequest(
        override val message: String = "Invalid user info request"): Exception(message)
  learner_created: true
- name: src/data/repository/database/exposed/table/MealToCategoryRelationTable.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.table

    import org.jetbrains.exposed.sql.Table

    object MealToCategoryRelationTable: Table() {
        val mealId = reference("meal_id", MealTable)
        val categoryId = reference("category_id", CategoryTable)
    }
  learner_created: true
- name: src/domain/exception/UnauthorizedAccessException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class UnauthorizedAccessException(
        override val message: String = "Unauthorized Access"): Exception(message)
  learner_created: true
- name: src/presentation/routing/ErrorRouting.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing

    import hotkitchen.domain.exception.*
    import hotkitchen.presentation.routing.responseDto.SignInResponse
    import hotkitchen.presentation.routing.responseDto.SignInResponse.Status.INVALID_SIGNIN
    import hotkitchen.presentation.routing.responseDto.SignupResponse
    import hotkitchen.presentation.routing.responseDto.SignupResponse.Status.*
    import io.ktor.application.*
    import io.ktor.features.*
    import io.ktor.http.*
    import io.ktor.response.*
    import io.ktor.util.pipeline.*

    object ErrorRouting {
        fun StatusPages.Configuration.errorRouting() {

            exception<SignupExistingUserException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignupResponse(DUPLICATED_USER))
            }

            exception<SignupInvalidEmailException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignupResponse(INVALID_EMAIL))
            }

            exception<SignupInvalidPasswordException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignupResponse(INVALID_PASS))
            }

            exception<DatabaseException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.InternalServerError, mapOf("error" to cause.localizedMessage))
            }

            exception<SigninAuthorizationFail> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignInResponse(INVALID_SIGNIN))
            }

            exception<UnauthorizedAccessException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Unauthorized, HttpStatusCode.Unauthorized)
            }

            exception<DeniedAccessException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, mapOf("status" to "Access denied"))
            }

            exception<InvalidUpdateException>(badRequest)

            exception<InvalidUserInfoRequest>(badRequest)

            exception<InvalidDeleteUserRequestException>(badRequest)

            exception<InvalidMealIdException>(badRequest)

            exception<InvalidCategoryIdException>(badRequest)

            exception<DuplicateMealException>(badRequest)

            exception<DuplicateCategoryException>(badRequest)
        }

        private fun logException(cause: Throwable) {
            println("Exception: ${cause.localizedMessage}")
            //cause.printStackTrace()
        }

        private val badRequest : suspend PipelineContext<Unit, ApplicationCall>.(cause : Throwable)  -> Unit =  { cause ->
            logException(cause)
            call.respond(HttpStatusCode.BadRequest, HttpStatusCode.BadRequest)
        }
    }
  learner_created: true
- name: src/data/repository/UserInfoRepository.kt
  visible: true
  text: |-
    package hotkitchen.data.repository

    import hotkitchen.data.repository.database.UserInfoDatabase
    import hotkitchen.domain.model.UserInfo

    class UserInfoRepository(private val userInfoDatabase: UserInfoDatabase) {



        fun getUserInfoByMail(email : String): UserInfo? {
            return userInfoDatabase.userInfoByEmail(email)
        }

        fun updateOrCreateUserInfo(name: String, phone: String, email: String, address: String): UserInfo? {
            return userInfoDatabase.updateOrCreateUserInfo(name, null, phone, email, address)
        }

        fun updateOrCreateUserInfo(name: String, userType: String, phone: String, email: String, address: String): UserInfo? {
            return userInfoDatabase.updateOrCreateUserInfo(name, userType, phone, email, address)
        }

        fun deleteUser(email: String) {
            userInfoDatabase.deleteUser(email)

        }
    }
  learner_created: true
- name: src/presentation/routing/responseDto/GetAllCategoryResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.Category

    data class GetAllCategoryResponse(private val categories: List<Category>) : List<Category> by categories, ApiResponse
  learner_created: true
- name: src/presentation/routing/UserInfoRouting.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing

    import hotkitchen.domain.model.User
    import hotkitchen.domain.service.UserInfoService
    import hotkitchen.domain.service.tokenService.jwtToken.JwtTokenService
    import hotkitchen.presentation.routing.requestDto.UserInfoUpdateRequest
    import hotkitchen.util.Extensions.getClaims
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*
    import io.ktor.http.*
    import io.ktor.request.*
    import io.ktor.response.*
    import io.ktor.routing.*

    object UserInfoRouting {

        fun Routing.userInfoRouting(userInfoService: UserInfoService, tokenService: JwtTokenService) {
            authenticate(tokenService.appScope) {
                get("/me")  {
                    println("headers ${call.request.headers}")
                    val (email, ) = call.getClaims("email")
                    val userInfo = userInfoService.getUserInfo(email)
                    println("email: $email")

                    call.respond(HttpStatusCode.OK, userInfo)
                }

                put("/me") {
                    println("headers ${call.request.headers}")
                    val userInfoUpdateRequest = call.receive<UserInfoUpdateRequest>()
                    println("requestBody $userInfoUpdateRequest")
                    val (email, userTypeStr) = call.getClaims("email", "userType")
                    println("email: $email, userType: $userTypeStr")

                    val response = userInfoService.updateUserInfo(email, User.Type.fromTypeString(userTypeStr)!!, userInfoUpdateRequest)

                    call.respond(HttpStatusCode.OK, response)
                }

                delete("/me") {
                    println("headers ${call.request.headers}")
                    val (email, ) = call.getClaims("email")
                    println("email: $email")

                    userInfoService.deleteUser(email)

                    call.respond(HttpStatusCode.OK, HttpStatusCode.OK)
                }
            }
        }
    }
  learner_created: true
- name: src/presentation/routing/responseDto/GetAllMealResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.Meal

    data class GetAllMealResponse(private val meals: List<Meal>) : List<Meal> by meals, ApiResponse
  learner_created: true
- name: src/domain/exception/DuplicateCategoryException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class DuplicateCategoryException(
        override val message: String = "There is already a category with this id registered"): Exception(message)
  learner_created: true
- name: src/presentation/routing/requestDto/SignInRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import kotlinx.serialization.Serializable

    @Serializable
    data class SignInRequest (
        val email: String,
        val password: String,
    )
  learner_created: true
- name: src/presentation/routing/MealRouting.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing

    import hotkitchen.domain.exception.DeniedAccessException
    import hotkitchen.domain.model.User
    import hotkitchen.domain.service.MealService
    import hotkitchen.presentation.routing.requestDto.AddCategoryRequest
    import hotkitchen.presentation.routing.requestDto.AddMealRequest
    import hotkitchen.presentation.routing.responseDto.ApiResponse
    import hotkitchen.util.Extensions.getClaims
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.http.*
    import io.ktor.request.*
    import io.ktor.response.*
    import io.ktor.routing.*

    object MealRouting {

        fun Routing.mealRouting(mealService: MealService) {
            authenticate("appScope") {


                route("/meals") {
                    post {
                        println("headers ${call.request.headers}")
                        val request = call.receive<AddMealRequest>()
                        println("requestBody $request")

                        val (userType, ) = call.getClaims("userType")
                        if(userType != User.Type.STAFF.typeString) {
                            throw DeniedAccessException()
                        } else {
                            val response = mealService.addMeal(request)
                            call.respond(HttpStatusCode.OK, response)
                        }
                    }

                    get {
                        println("headers ${call.request.headers}")
                        println("query parameters ${call.request.queryParameters}")
                        val maybeMealId = call.request.queryParameters["id"]

                        val response = if(maybeMealId == null) {
                            mealService.getMealList()
                        } else {
                            mealService.getMeal(maybeMealId)
                        }

                        call.respond(HttpStatusCode.OK, response)
                    }
                }



                route("/categories") {

                    post {
                        println("headers ${call.request.headers}")
                        val request = call.receive<AddCategoryRequest>()
                        println("requestBody $request")

                        val (userType, ) = call.getClaims("userType")

                        if (userType != User.Type.STAFF.typeString) {
                            throw DeniedAccessException()
                        } else {
                            val response = mealService.addCategory(request)
                            call.respond(HttpStatusCode.OK, response)
                        }
                    }

                    get {
                        println("headers ${call.request.headers}")
                        println("query parameters ${call.request.queryParameters}")
                        val maybeCategoryId = call.request.queryParameters["id"]

                        val response: ApiResponse = if(maybeCategoryId == null) {
                            mealService.getListCategory()
                        } else {
                            mealService.getCategory(maybeCategoryId)
                        }

                        call.respond(HttpStatusCode.OK, response)
                    }
                }
            }

        }
    }
  learner_created: true
- name: src/presentation/routing/requestDto/SignUpRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import hotkitchen.domain.model.User
    import kotlinx.serialization.Serializable

    @Serializable
    data class SignUpRequest (
        val email: String,
        val userType: User.Type,
        val password: String,
    )
  learner_created: true
- name: src/data/repository/database/exposed/table/CategoryTable.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.table

    import org.jetbrains.exposed.dao.id.EntityID
    import org.jetbrains.exposed.dao.id.IdTable
    import org.jetbrains.exposed.sql.Column

    object CategoryTable: IdTable<Int>() {
        override val id: Column<EntityID<Int>> = integer("category_id").uniqueIndex().entityId()
        val title: Column<String> = varchar("title", 200)
        val description: Column<String> = varchar("description", 1000)
    }
  learner_created: true
- name: src/presentation/routing/responseDto/SignupResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import kotlinx.serialization.SerialName
    import kotlinx.serialization.Serializable

    @Serializable
    data class SignupResponse(
        val status: Status
    ): ApiResponse {
        @Serializable
        enum class Status {
            @SerialName("Signed In") SIGNED_UP,
            @SerialName("Registration failed") REGISTRATION_FAILED,
            @SerialName("Invalid email") INVALID_EMAIL,
            @SerialName("Invalid password") INVALID_PASS,
            @SerialName("User already exists") DUPLICATED_USER
            ;
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/table/MealTable.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.table

    import org.jetbrains.exposed.dao.id.EntityID
    import org.jetbrains.exposed.dao.id.IdTable
    import org.jetbrains.exposed.sql.Column

    object MealTable: IdTable<Int>() {
        override val id: Column<EntityID<Int>> = integer("meal_id").uniqueIndex().entityId()
        val title: Column<String> = varchar("title", 200)
        val price: Column<Double> = double("price")
        val imageUrl: Column<String> =  varchar("image_url", 300)
        val categories: Column<String> = varchar("categories" ,500)
    }
  learner_created: true
- name: src/presentation/routing/responseDto/SignInResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import kotlinx.serialization.SerialName
    import kotlinx.serialization.Serializable

    @Serializable
    data class SignInResponse (
        val status: Status
    ): ApiResponse {
        @Serializable
        enum class Status {
            @SerialName("Signed Up") SIGNED_IN,
            @SerialName("Authorization failed") AUTHORIZATION_FAILED,
            @SerialName("Invalid email or password") INVALID_SIGNIN,
            ;
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/entity/UserInfoEntity.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.entity

    import hotkitchen.data.repository.database.exposed.table.UserInfoTable
    import hotkitchen.domain.model.User
    import hotkitchen.domain.model.UserInfo
    import org.jetbrains.exposed.dao.IntEntity
    import org.jetbrains.exposed.dao.IntEntityClass
    import org.jetbrains.exposed.dao.id.EntityID

    class UserInfoEntity(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<UserInfoEntity>(UserInfoTable)

        var name: String by UserInfoTable.name
        var phone: String by UserInfoTable.phone
        var address: String by UserInfoTable.address
        var user: UserCredentialsEntity by UserCredentialsEntity referencedOn UserInfoTable.user


        fun toUserInfo(): UserInfo {
            return UserInfo(user.email, User.Type.valueOf(user.userType), name, phone, address)
        }
    }
  learner_created: true
- name: src/domain/model/UserInfo.kt
  visible: true
  text: |-
    package hotkitchen.domain.model

    import kotlinx.serialization.Serializable

    @Serializable
    data class UserInfo(
        val email: String,
        val type: User.Type,
        val name: String,
        val phone: String,
        val address: String
    )
  learner_created: true
- name: src/domain/exception/InvalidCategoryIdException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class InvalidCategoryIdException(
        override val message: String = "Invalid mealId, mealId should be an integer number"): Exception(message)
  learner_created: true
- name: src/presentation/routing/responseDto/UserInfoResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.User
    import hotkitchen.domain.model.UserInfo
    import kotlinx.serialization.Serializable

    @Serializable
    data class UserInfoResponse(
        val email: String,
        val userType: User.Type,
        val name: String,
        val phone: String,
        val address: String
    ): ApiResponse {
        companion object {
            fun fromUserInfo(userInfo: UserInfo): UserInfoResponse {
                return UserInfoResponse(
                    userInfo.email,
                    userInfo.type,
                    userInfo.name,
                    userInfo.phone,
                    userInfo.address
                )
            }
        }
    }
  learner_created: true
- name: src/domain/exception/SigninAuthorizationFail.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SigninAuthorizationFail(
        override val message: String = "Failed authorization"): Exception(message)
  learner_created: true
- name: src/presentation/routing/responseDto/AddCategoryResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.Category
    import kotlinx.serialization.Serializable

    @Serializable
    data class AddCategoryResponse(val category: Category) : ApiResponse
  learner_created: true
- name: src/domain/exception/InvalidUpdateException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class InvalidUpdateException(
        override val message: String = "Invalid update"): Exception(message)
  learner_created: true
- name: src/domain/exception/InvalidDeleteUserRequestException.kt
  visible: true
  text: |
    package hotkitchen.domain.exception

    class InvalidDeleteUserRequestException(
        override val message: String = "Invalid delete user request"): Exception(message)
  learner_created: true
- name: src/data/repository/database/exposed/table/UserInfoTable.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.table

    import org.jetbrains.exposed.dao.id.EntityID
    import org.jetbrains.exposed.dao.id.IntIdTable
    import org.jetbrains.exposed.sql.Column

    object UserInfoTable : IntIdTable()  {
        val name: Column<String> = varchar("name", 100)
        val phone: Column<String> = varchar("phone", 20)
        val address: Column<String> = varchar("address", 300)
        val user: Column<EntityID<Int>> = reference("user", UserCredentialsTable).uniqueIndex()
    }
  learner_created: true
- name: src/presentation/routing/responseDto/GetCategoryResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.Category
    import kotlinx.serialization.Serializable

    @Serializable
    data class GetCategoryResponse (
        val categoryId: Int,
        val title: String,
        val description: String
    ): ApiResponse {
        companion object {
            fun fromCategory(category: Category): GetCategoryResponse {
                return GetCategoryResponse(
                    categoryId = category.categoryId,
                    title = category.title,
                    description = category.description
                )
            }
        }
    }
  learner_created: true
- name: src/data/repository/MealRepository.kt
  visible: true
  text: |-
    package hotkitchen.data.repository

    import hotkitchen.data.repository.database.MealDatabase
    import hotkitchen.domain.exception.DuplicateCategoryException
    import hotkitchen.domain.exception.DuplicateMealException
    import hotkitchen.domain.exception.InvalidCategoryIdException
    import hotkitchen.domain.exception.InvalidMealIdException
    import hotkitchen.domain.model.Category
    import hotkitchen.domain.model.Meal
    import hotkitchen.presentation.routing.requestDto.AddCategoryRequest
    import hotkitchen.presentation.routing.requestDto.AddMealRequest

    class MealRepository(private val mealDatabase: MealDatabase) {
        fun addMeal(addMealRequest: AddMealRequest): Meal? {

            val mealId = addMealRequest.mealId.toIntOrNull() ?: throw InvalidMealIdException()

            val maybeMeal = mealDatabase.getMeal(mealId)

            if(maybeMeal != null) {
                throw DuplicateMealException()
            }

            return mealDatabase.addMeal(
                mealId,
                addMealRequest.title,
                addMealRequest.price,
                addMealRequest.imageUrl,
                addMealRequest.categoryIds
            )
        }

        fun addCategory(addCategoryRequest: AddCategoryRequest): Category? {

            val maybeCategory = mealDatabase.getCategory(addCategoryRequest.categoryId)

            if(maybeCategory != null) {
                throw DuplicateCategoryException()
            }

            return mealDatabase.addCategory(
                addCategoryRequest.categoryId,
                addCategoryRequest.title,
                addCategoryRequest.description
            )
        }

        fun getMeal(mealId: String): Meal? {
            val mealIdInt = mealId.toIntOrNull() ?: throw InvalidMealIdException()
            return mealDatabase.getMeal(mealIdInt)
        }

        fun getCategory(categoryId: String): Category? {
            val categoryIdInt = categoryId.toIntOrNull() ?: throw InvalidCategoryIdException()
            return mealDatabase.getCategory(categoryIdInt)
        }

        fun getMealList(): List<Meal> {
            return mealDatabase.getMealList()
        }

        fun getCategoryList(): List<Category> {
            return mealDatabase.getCategoryList()
        }
    }
  learner_created: true
- name: src/domain/model/Meal.kt
  visible: true
  text: |-
    package hotkitchen.domain.model

    import kotlinx.serialization.Serializable

    @Serializable
    data class Meal (
        val mealId: Int,
        val title: String,
        val price: Double,
        val imageUrl: String,
        val categoryIds: List<Int>
    )
  learner_created: true
- name: src/domain/service/MealService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service

    import hotkitchen.data.repository.MealRepository
    import hotkitchen.domain.exception.DatabaseException
    import hotkitchen.domain.model.Category
    import hotkitchen.domain.model.Meal
    import hotkitchen.presentation.routing.requestDto.AddCategoryRequest
    import hotkitchen.presentation.routing.requestDto.AddMealRequest
    import hotkitchen.presentation.routing.responseDto.*

    class MealService(private val mealRepository: MealRepository) {
        fun addMeal(addMealRequest: AddMealRequest): ApiResponse {
            val meal: Meal = mealRepository.addMeal(addMealRequest) ?: throw DatabaseException()

            return AddMealResponse(meal)
        }

        fun addCategory(addCategoryRequest: AddCategoryRequest): ApiResponse {

            val category: Category = mealRepository.addCategory(addCategoryRequest) ?: throw DatabaseException()

            return AddCategoryResponse(category)
        }

        fun getMeal(categoryId: String): ApiResponse {

            val meal: Meal = mealRepository.getMeal(categoryId) ?: throw DatabaseException()

            return GetMealResponse.fromMeal(meal)
        }

        fun getMealList(): ApiResponse {
            return GetAllMealResponse(mealRepository.getMealList())
        }

        fun getCategory(categoryId: String): ApiResponse {

            val category: Category = mealRepository.getCategory(categoryId) ?: throw DatabaseException()

            return GetCategoryResponse.fromCategory(category)
        }

        fun getListCategory(): ApiResponse {
            return GetAllCategoryResponse(mealRepository.getCategoryList())
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/ExposedH2UserInfoDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import hotkitchen.data.repository.database.UserInfoDatabase
    import hotkitchen.data.repository.database.exposed.entity.UserCredentialsEntity
    import hotkitchen.data.repository.database.exposed.entity.UserInfoEntity
    import hotkitchen.data.repository.database.exposed.table.UserCredentialsTable
    import hotkitchen.data.repository.database.exposed.table.UserInfoTable
    import hotkitchen.domain.exception.InvalidDeleteUserRequestException
    import hotkitchen.domain.model.UserInfo
    import org.jetbrains.exposed.sql.Database
    import org.jetbrains.exposed.sql.insertAndGetId
    import org.jetbrains.exposed.sql.select
    import org.jetbrains.exposed.sql.transactions.transaction
    import org.jetbrains.exposed.sql.update

    class ExposedH2UserInfoDatabase(private val database: Database): UserInfoDatabase {
        override fun userInfoByEmail(email: String): UserInfo? {
            return transaction(database) {

                val query = UserInfoTable.innerJoin(UserCredentialsTable).select {
                    UserCredentialsTable.email eq email
                }
                val userInfo = UserInfoEntity.wrapRows(query).firstOrNull()?.toUserInfo()

                userInfo
            }
        }

        override fun updateOrCreateUserInfo(
            name: String,
            userType: String?,
            phone: String,
            email: String,
            address: String
        ): UserInfo? {
            return transaction(database) {

                if(userType != null) {
                    UserCredentialsTable.update({ UserCredentialsTable.email eq email }) {
                        it[UserCredentialsTable.userType] = userType
                    }
                }

                val query = UserInfoTable.innerJoin(UserCredentialsTable).select {
                    UserCredentialsTable.email eq email
                }
                val maybeUserInfoEntity = UserInfoEntity.wrapRows(query).firstOrNull()

                val userInfoId = if(maybeUserInfoEntity != null) {
                    UserInfoTable.update({ UserInfoTable.id eq maybeUserInfoEntity.id}) {
                        it[this.name] = name
                        it[this.phone] = phone
                        it[this.address] = address
                    }
                    maybeUserInfoEntity.id
                } else {
                    val userCredentialsEntity = UserCredentialsEntity.find {
                        UserCredentialsTable.email eq email
                    }.firstOrNull()!!

                    UserInfoTable.insertAndGetId {
                        it[this.address] = address
                        it[this.name] = name
                        it[this.user] = userCredentialsEntity.id
                        it[this.phone] = phone
                    }
                }

                UserInfoEntity.find {
                    UserInfoTable.id eq userInfoId
                }.firstOrNull()?.toUserInfo()
            }
        }

        override fun deleteUser(email: String) {
            return transaction(database) {



                val query = UserInfoTable.innerJoin(UserCredentialsTable).select {
                    UserCredentialsTable.email eq email
                }
                val maybeUserInfoEntity = UserInfoEntity.wrapRows(query).firstOrNull() ?: throw InvalidDeleteUserRequestException()

                maybeUserInfoEntity.delete()
                maybeUserInfoEntity.user.delete()
            }
        }
    }
  learner_created: true
- name: src/domain/model/User.kt
  visible: true
  text: |
    package hotkitchen.domain.model

    import kotlinx.serialization.SerialName
    import kotlinx.serialization.Serializable
    import java.util.EnumSet

    @Serializable
    data class User (
        val email: String,
        val type: Type,
        val password: String,
    ) {
        @Serializable
        @Suppress("unused")
        enum class Type(val typeString: String) {
            @SerialName("staff") STAFF("staff"),
            @SerialName("testUser") TEST_USER("testUser"),
            @SerialName("client") CLIENT("client"),
            @SerialName("newType") NEW_TYPE("newType"),
            ;

            companion object {
                private val allValues = EnumSet.allOf(User.Type::class.java)

                fun fromTypeString(typeString: String): User.Type? {
                    return allValues.firstOrNull { it.typeString == typeString }
                }
            }
        }
    }
  learner_created: true
- name: src/data/repository/UserCredentialsRepository.kt
  visible: true
  text: |-
    package hotkitchen.data.repository

    import hotkitchen.domain.exception.SignupExistingUserException
    import hotkitchen.domain.exception.DatabaseException
    import hotkitchen.data.repository.database.UserCredentialsDatabase
    import hotkitchen.domain.model.User

    class UserCredentialsRepository(private val userCredentialsDatabase: UserCredentialsDatabase) {

        fun addUser(email: String, type: User.Type, password: String): User {
            val maybeUser = userCredentialsDatabase.userByEmail(email)

            if(maybeUser != null) {
                throw SignupExistingUserException("There is already an user with ${email} registered")
            }

            val maybeUserAdded = userCredentialsDatabase.addUser(email, type, password)

            return maybeUserAdded ?: throw DatabaseException()
        }

        fun getUser(email: String): User? {
            return userCredentialsDatabase.userByEmail(email)
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/ExposedH2UserCredentialsDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import hotkitchen.data.repository.database.UserCredentialsDatabase
    import hotkitchen.data.repository.database.exposed.entity.UserCredentialsEntity
    import hotkitchen.data.repository.database.exposed.table.UserCredentialsTable
    import hotkitchen.domain.model.User
    import org.jetbrains.exposed.sql.Database
    import org.jetbrains.exposed.sql.transactions.transaction

    class ExposedH2UserCredentialsDatabase(private val database: Database): UserCredentialsDatabase {
        override fun userByEmail(email: String): User? {
            return transaction(database) {
                UserCredentialsEntity.find {
                    UserCredentialsTable.email eq email
                }.firstOrNull()
                    ?.toUser()
            }
        }

        override fun addUser(email: String, type: User.Type, password: String): User? {
            return try {
                transaction(database) {
                    UserCredentialsEntity.new {
                        this.email = email
                        this.userType = type.name
                        this.password = password
                    }
                }.toUser()
            } catch (e: Exception) {
                null
            }
        }
    }
  learner_created: true
- name: src/domain/exception/DuplicateMealException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class DuplicateMealException(
        override val message: String = "There is already a meal with this id registered"): Exception(message)
  learner_created: true
- name: src/presentation/routing/responseDto/TokenResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import kotlinx.serialization.Serializable

    @Serializable
    data class TokenResponse(val token: String = "abc.def.***") : ApiResponse
  learner_created: true
- name: src/domain/service/UserInfoService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service

    import hotkitchen.data.repository.UserInfoRepository
    import hotkitchen.domain.exception.DatabaseException
    import hotkitchen.domain.exception.InvalidUpdateException
    import hotkitchen.domain.exception.InvalidUserInfoRequest
    import hotkitchen.domain.model.User
    import hotkitchen.presentation.routing.requestDto.UserInfoUpdateRequest
    import hotkitchen.presentation.routing.responseDto.ApiResponse
    import hotkitchen.presentation.routing.responseDto.UserInfoResponse

    class UserInfoService(private val userInfoRepository: UserInfoRepository) {

        fun getUserInfo(email: String): ApiResponse {

            return UserInfoResponse.fromUserInfo(
                userInfoRepository.getUserInfoByMail(email) ?: throw InvalidUserInfoRequest()
            )
        }

        fun updateUserInfo(email: String, userType: User.Type, userInfoUpdateRequest: UserInfoUpdateRequest): ApiResponse {

            if(email !=  userInfoUpdateRequest.email) {
                throw InvalidUpdateException("Invalid update for user info, email cannot be changed")
            }

            val (name, requestUserType, phone, requestEmail, address) = userInfoUpdateRequest

            val userInfo = if(userType != requestUserType) {
                userInfoRepository.updateOrCreateUserInfo(name, requestUserType.name, phone, requestEmail, address)
            } else {
                userInfoRepository.updateOrCreateUserInfo(name, phone, requestEmail, address)
            } ?: throw DatabaseException()

            return UserInfoResponse.fromUserInfo(userInfo)
        }

        fun deleteUser(email: String) {
            userInfoRepository.deleteUser(email)
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/table/UserCredentialsTable.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.table

    import org.jetbrains.exposed.dao.id.IntIdTable
    import org.jetbrains.exposed.sql.Column

    object UserCredentialsTable : IntIdTable() {
        val email: Column<String> = varchar("email", 100).uniqueIndex()
        val password: Column<String> = varchar("password", 100)
        val userType: Column<String> = varchar("user_type", 50)
    }
  learner_created: true
- name: src/data/repository/database/exposed/entity/UserCredentialsEntity.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.entity

    import hotkitchen.data.repository.database.exposed.table.UserCredentialsTable
    import hotkitchen.domain.model.User
    import org.jetbrains.exposed.dao.IntEntity
    import org.jetbrains.exposed.dao.IntEntityClass
    import org.jetbrains.exposed.dao.id.EntityID

    class UserCredentialsEntity(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<UserCredentialsEntity>(UserCredentialsTable)

        var email: String by UserCredentialsTable.email
        var password: String by UserCredentialsTable.password
        var userType: String by UserCredentialsTable.userType

        fun toUser(): User {
            return User(email, User.Type.valueOf(userType), password)
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/entity/MealEntity.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed.entity

    import hotkitchen.data.repository.database.exposed.table.MealTable
    import hotkitchen.data.repository.database.exposed.table.MealToCategoryRelationTable
    import hotkitchen.domain.model.Meal
    import org.jetbrains.exposed.dao.IntEntity
    import org.jetbrains.exposed.dao.IntEntityClass
    import org.jetbrains.exposed.dao.id.EntityID
    import org.jetbrains.exposed.sql.SizedIterable

    class MealEntity(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<MealEntity>(MealTable)

        var title: String by MealTable.title
        var price: Double by MealTable.price
        var imageUrl: String by MealTable.imageUrl
        var categories: List<Int> by MealTable.categories.transform(
            toColumn = { it.joinToString(" ") },
            toReal = { it.split(' ').map(String::toInt)}
        )


        fun toMeal(): Meal {
            return Meal(
                id.value,
                title,
                price,
                imageUrl,
                categories
            )
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/ExposedDatabaseConnection.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import org.jetbrains.exposed.sql.*
    import org.jetbrains.exposed.sql.transactions.transaction

    class ExposedDatabaseConnection(private vararg val tables: Table) {
        val database = Database.connect("jdbc:h2:mem:regular;DB_CLOSE_DELAY=-1;", "org.h2.Driver")

        init {
            transaction(database) {
                tables.forEach {
                    SchemaUtils.create(it)
                }
                addLogger(StdOutSqlLogger)
            }
        }
    }
  learner_created: true
- name: src/presentation/routing/responseDto/SimpleStatusResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import kotlinx.serialization.Serializable

    @Serializable
    data class SimpleStatusResponse (
        val status: String
    ) : ApiResponse
  learner_created: true
- name: src/domain/service/UserCredentialsService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service

    import hotkitchen.domain.exception.SigninAuthorizationFail
    import hotkitchen.domain.exception.SignupInvalidEmailException
    import hotkitchen.domain.exception.SignupInvalidPasswordException
    import hotkitchen.presentation.routing.requestDto.SignInRequest
    import hotkitchen.presentation.routing.requestDto.SignUpRequest
    import hotkitchen.presentation.routing.responseDto.ApiResponse
    import hotkitchen.presentation.routing.responseDto.TokenResponse
    import hotkitchen.data.repository.UserCredentialsRepository
    import hotkitchen.domain.service.tokenService.TokenService
    import hotkitchen.util.Validation.isNotValidEmail
    import hotkitchen.util.Validation.isNotValidPass

    class UserCredentialsService(private val userCredentialsRepository: UserCredentialsRepository, private val tokenService: TokenService) {

        fun signInUser(signInRequest: SignInRequest): ApiResponse {
            val maybeUser = userCredentialsRepository.getUser(signInRequest.email)

            return if (maybeUser?.password != signInRequest.password) {
                throw SigninAuthorizationFail()
            } else {
                TokenResponse(tokenService.produceToken(maybeUser.type, maybeUser.email))
            }
        }

        fun signUpUser(signUpRequest: SignUpRequest): ApiResponse {
            val (email, type, password) = signUpRequest

            if(email.isNotValidEmail()) {
                throw SignupInvalidEmailException()
            } else if(password.isNotValidPass()) {
                throw SignupInvalidPasswordException()
            }

            userCredentialsRepository.addUser(email, type, password)
            return TokenResponse(tokenService.produceToken(type, email))
        }
    }
  learner_created: true
- name: src/domain/service/tokenService/jwtToken/JwtTokenService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service.tokenService.jwtToken

    import com.auth0.jwt.JWT
    import com.auth0.jwt.algorithms.Algorithm
    import hotkitchen.domain.exception.DeniedAccessException
    import hotkitchen.domain.exception.UnauthorizedAccessException
    import hotkitchen.domain.model.User
    import hotkitchen.domain.service.tokenService.TokenService
    import hotkitchen.util.Validation.isNotValidEmail
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*
    import java.util.*

    class JwtTokenService(environment: ApplicationEnvironment): TokenService {

        private val secret = environment.config.property("jwt.secret").getString()
        private val issuer = environment.config.property("jwt.issuer").getString()
        private val audience = environment.config.property("jwt.audience").getString()
        private val expirationTime = 1000 * 60 * 10
        private val algorithm = Algorithm.HMAC256(secret)

        private val realm = environment.config.property("jwt.realm").getString()
        private val jwtVerifier = JWT.require(algorithm)
            .withAudience(audience)
            .withIssuer(issuer)
            .withClaimPresence("email")
            .withClaimPresence("userType")
            .build()
        val appScope = "appScope"

        val authConfig: Authentication.Configuration.() -> Unit = {
            jwt(appScope) {
                realm = this@JwtTokenService.realm
                verifier(jwtVerifier)

                validate { credential ->
                    val payload = credential.payload
                    val email = payload.getClaim("email").asString()
                    if(email.isNotValidEmail()) {
                        null
                    } else {
                        JWTPrincipal(payload)
                    }
                }

                challenge { _, _ ->
                    throw UnauthorizedAccessException()
                }
            }
        }

        override fun isValidToken(tokenString: String): Boolean {

            return try {
                jwtVerifier.verify(tokenString)
                true
            } catch (e: Exception) {
                false
            }
        }

        override fun produceToken(userType: User.Type, email: String): String {
            return JWT.create()
                .withAudience(audience)
                .withIssuer(issuer)
                .withClaim("email", email)
                .withClaim("userType", userType.typeString)
                .withExpiresAt(Date(System.currentTimeMillis() + expirationTime))
                .sign(algorithm)
        }

        override fun decodeToken(tokenString: String): Pair<String, String> {
            val jwt = JWT.decode(tokenString)
            val email = jwt.getClaim("email").asString()
            val userType = jwt.getClaim("userType").asString()

            return userType to email
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/ExposedH2MealDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import hotkitchen.data.repository.database.MealDatabase
    import hotkitchen.data.repository.database.exposed.entity.CategoryEntity
    import hotkitchen.data.repository.database.exposed.entity.MealEntity
    import hotkitchen.data.repository.database.exposed.table.CategoryTable
    import hotkitchen.data.repository.database.exposed.table.MealTable
    import hotkitchen.domain.model.Category
    import hotkitchen.domain.model.Meal
    import org.jetbrains.exposed.sql.Database
    import org.jetbrains.exposed.sql.Op
    import org.jetbrains.exposed.sql.insertAndGetId
    import org.jetbrains.exposed.sql.transactions.transaction

    class ExposedH2MealDatabase(private val database: Database): MealDatabase {
        override fun addMeal(
            mealId: Int,
            title: String,
            price: Double,
            imageUrl: String,
            categoryIds: List<Int>
        ): Meal? {
            return transaction(database) {
                val mealId = MealTable.insertAndGetId {
                    it[MealTable.id] = mealId
                    it[MealTable.title] = title
                    it[MealTable.price] = price
                    it[MealTable.imageUrl] = imageUrl
                    it[MealTable.categories] = categoryIds.joinToString(" ")
                }


               MealEntity.find {
                    MealTable.id eq mealId
                }.firstOrNull()?.toMeal()
            }
        }

        override fun getMeal(mealId: Int): Meal? {
            return transaction(database) {
                MealEntity.findById(mealId)
            }?.toMeal()
        }

        override fun getMealList(): List<Meal> {
            return transaction(database) {
                MealEntity.all().map(MealEntity::toMeal)
            }
        }

        override fun addCategory(categoryId: Int, title: String, description: String): Category? {
            return transaction(database) {
                val categoryId = CategoryTable.insertAndGetId {
                    it[CategoryTable.id] = categoryId
                    it[CategoryTable.title] = title
                    it[CategoryTable.description] = description
                }

                CategoryEntity.find {
                    CategoryTable.id eq categoryId
                }.firstOrNull()?.toCategory()
            }
        }

        override fun getCategory(categoryId: Int): Category? {
            return transaction(database) {
                CategoryEntity.findById(categoryId)
            }?.toCategory()
        }

        override fun getCategoryList(): List<Category> {
            return transaction(database) {
                CategoryEntity.all().map(CategoryEntity::toCategory)
            }
        }
    }
  learner_created: true
- name: src/presentation/routing/requestDto/UserInfoUpdateRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import hotkitchen.domain.model.User
    import kotlinx.serialization.Serializable


    @Serializable
    data class UserInfoUpdateRequest (
        val name: String,
        val userType: User.Type,
        val phone: String,
        val email: String,
        val address: String,
    )
  learner_created: true
- name: src/presentation/routing/requestDto/AddCategoryRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import kotlinx.serialization.Serializable

    @Serializable
    data class AddCategoryRequest (
        val categoryId: Int,
        val title: String,
        val description: String
    )
  learner_created: true
- name: test/testdata/Credentials.kt
  visible: false
  text: |
    package testdata

    import kotlinx.serialization.Serializable

    @Serializable
    data class Credentials(var email: String, var userType: String, var password: String)
  learner_created: false
- name: test/testdata/Token.kt
  visible: false
  text: |-
    package testdata
    import kotlinx.serialization.Serializable

    @Serializable
    data class Token(val token: String)
  learner_created: false
- name: test/testdata/Meal.kt
  visible: false
  text: |-
    package testdata

    import kotlinx.serialization.Serializable

    @Serializable
    data class Meal(
        val mealId: Int,
        val title: String,
        val price: Float,
        val imageUrl: String,
        val categoryIds: List<Int>
    )
  learner_created: false
- name: test/testdata/User.kt
  visible: false
  text: |-
    package testdata

    import kotlinx.serialization.Serializable

    @Serializable
    data class User(
        val name: String, val userType: String, val phone: String, val email: String, val address: String
    )
  learner_created: false
- name: test/testdata/Order.kt
  visible: false
  text: |-
    package testdata

    import kotlinx.serialization.Serializable

    @Serializable
    data class Order(
        var orderId: Int,
        val userEmail: String,
        val mealsIds: List<Int>,
        val price: Float,
        val address: String,
        val status: String
    )
  learner_created: false
- name: src/presentation/routing/OrderRouting.kt
  visible: true
  learner_created: true
- name: src/data/repository/OrderRepository.kt
  visible: true
  learner_created: true
- name: src/domain/service/OrderService.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/requestDto/CreateOrderRequest.kt
  visible: true
  learner_created: true
- name: src/domain/model/Order.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/CreateOrderResponse.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/OrderDatabase.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/ExposedH2OrderDatabase.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/table/OrderTable.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/entity/OrderEntity.kt
  visible: true
  learner_created: true
- name: src/domain/exception/UserInfoNotFoundException.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/GetListOrdersResponse.kt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/22607#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Sun, 06 Nov 2022 19:51:29 UTC
record: 5
