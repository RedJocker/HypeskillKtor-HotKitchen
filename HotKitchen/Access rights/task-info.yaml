type: edu
files:
- name: build.gradle
  visible: true
  text: |-
    buildscript {
        repositories {
            mavenCentral()
        }
        dependencies {
            classpath "org.jetbrains.kotlin:kotlin-serialization:1.6.21"
        }
    }
    def ktor_version = "1.6.7"

    apply plugin: 'java'
    apply plugin: 'org.jetbrains.kotlin.jvm'
    apply plugin: 'kotlin'
    apply plugin: 'kotlinx-serialization'

    repositories {
        mavenCentral()
    }


    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation "org.jetbrains.kotlin:kotlin-stdlib"
        implementation "io.ktor:ktor-server-core:$ktor_version"
        implementation "io.ktor:ktor-server-netty:$ktor_version"
        implementation("ch.qos.logback:logback-classic:1.2.10")

        implementation "io.ktor:ktor-serialization:$ktor_version"
        implementation('org.jetbrains.exposed:exposed-core:0.37.3')
        implementation('org.jetbrains.exposed:exposed-dao:0.37.3')
        implementation('org.jetbrains.exposed:exposed-jdbc:0.37.3')
        implementation('com.zaxxer:HikariCP:5.0.1')
        implementation("org.postgresql:postgresql:42.3.2")
    }
  learner_created: false
- name: src/resources/application.conf
  visible: true
  text: |-
    ktor {
        deployment {
            port = 28888
        }
        application {
            modules = [hotkitchen.ApplicationKt.module]
        }
    }
  learner_created: false
- name: src/Application.kt
  visible: true
  text: |-
    package hotkitchen

    import io.ktor.application.*

    fun main(args: Array<String>): Unit = io.ktor.server.netty.EngineMain.main(args)

    fun Application.module(testing: Boolean = false) {}
  learner_created: false
- name: test/HotKitchenTest.kt
  visible: false
  text: |-
    import com.typesafe.config.ConfigFactory
    import io.ktor.config.*
    import io.ktor.http.*
    import io.ktor.server.testing.*
    import kotlinx.serialization.Serializable
    import kotlinx.serialization.decodeFromString
    import kotlinx.serialization.encodeToString
    import kotlinx.serialization.json.Json
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult

    class HotKitchenTest : StageTest<Any>() {

        @Serializable
        private data class Credentials(var email: String, var userType: String, var password: String)

        @Serializable
        private data class Token(val token: String)

        @Serializable
        data class Meal(
            val mealId: Int,
            val title: String,
            val price: Float,
            val imageUrl: String,
            val categoryIds: List<Int>
        )

        @Serializable
        data class Category(
            val categoryId: Int,
            val title: String,
            val description: String
        )

        private val time = System.currentTimeMillis()
        private val jwtRegex = """^[a-zA-Z0-9]+?\.[a-zA-Z0-9]+?\..+""".toRegex()
        private val accessDenied = """{"status":"Access denied"}"""
        private val currentCredentialsClient = Credentials("$time@client.com", "client", "password$time")
        private val currentCredentialsStaff = Credentials("$time@staff.com", "staff", "password$time")
        private val currentMeal = Meal(
            time.toInt(),
            "$time title",
            (time.toInt() % 100).toFloat(),
            "image $time url",
            listOf((0..10).random(), (0..10).random(), (0..10).random())
        )
        private val currentCategory = Category(
            time.toInt(),
            "$time TITLE",
            "Awesome $time description"
        )
        private lateinit var signInTokenClient: String
        private lateinit var signInTokenStaff: String


        @DynamicTest(order = 1)
        fun getSignInJWTToken(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentialsClient))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                try {
                    val principal = Json.decodeFromString<Token>(response.content ?: "")
                    signInTokenClient = principal.token
                    if (!signInTokenClient.matches(jwtRegex) || signInTokenClient.contains(currentCredentialsClient.email))
                        return@withApplication CheckResult.wrong("Invalid JWT token")
                } catch (e: Exception) {
                    return@withApplication CheckResult.wrong("Cannot get token form /signin request")
                }
            }
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentialsStaff))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                try {
                    val principal = Json.decodeFromString<Token>(response.content ?: "")
                    signInTokenStaff = principal.token
                    if (!signInTokenStaff.matches(jwtRegex) || signInTokenStaff.contains(currentCredentialsStaff.email))
                        return@withApplication CheckResult.wrong("Invalid JWT token")
                } catch (e: Exception) {
                    return@withApplication CheckResult.wrong("Cannot get token form /signin request")
                }
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 2)
        fun correctValidation(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/validate") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.status() != HttpStatusCode.OK || response.content != "Hello, ${currentCredentialsClient.userType} ${currentCredentialsClient.email}") return@withApplication CheckResult.wrong(
                    "Token validation with signin token failed.\nStatus code should be \"200 OK\"\nMessage should be \"Hello, ${currentCredentialsClient.userType} ${currentCredentialsClient.email}\""
                )
            }
            with(handleRequest(HttpMethod.Get, "/validate") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
            }) {
                if (response.status() != HttpStatusCode.OK || response.content != "Hello, ${currentCredentialsStaff.userType} ${currentCredentialsStaff.email}") return@withApplication CheckResult.wrong(
                    "Token validation with signin token failed.\nStatus code should be \"200 OK\"\nMessage should be \"Hello, ${currentCredentialsStaff.userType} ${currentCredentialsStaff.email}\""
                )
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 3)
        fun accessDeniedAdditionMeal(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/meals") {
                setBody(Json.encodeToString(currentMeal))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.Forbidden || response.content != accessDenied)
                    return@withApplication CheckResult.wrong("Only staff can add meal. Wrong response or status code")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 4)
        fun accessDeniedAdditionCategory(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/categories") {
                setBody(Json.encodeToString(currentCategory))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.Forbidden || response.content != accessDenied)
                    return@withApplication CheckResult.wrong("Only staff can add category. Wrong response or status code")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 5)
        fun successAdditionMeal(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/meals") {
                setBody(Json.encodeToString(currentMeal))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("The meal was not added. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 6)
        fun failedAdditionMeal(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/meals") {
                setBody(Json.encodeToString(currentMeal))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("The meal was added twice. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 7)
        fun successAdditionCategory(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/categories") {
                setBody(Json.encodeToString(currentCategory))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("The category was not added. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 8)
        fun failedAdditionCategory(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/categories") {
                setBody(Json.encodeToString(currentCategory))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("The category was added twice. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 9)
        fun getMealById(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/meals?id=${currentMeal.mealId}") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.content != Json.encodeToString(currentMeal))
                    return@withApplication CheckResult.wrong("Wrong meal by id.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 10)
        fun getCategoryById(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/categories?id=${currentCategory.categoryId}") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.content != Json.encodeToString(currentCategory))
                    return@withApplication CheckResult.wrong("Wrong category by id.")
            }
            return@withApplication CheckResult.correct()
        }


        @DynamicTest(order = 11)
        fun getMeals(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/meals") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                val meals: List<Meal> = Json.decodeFromString(response.content ?: "")
                var flag = true
                for (meal in meals) {
                    if (meal.mealId == currentMeal.mealId) {
                        flag = false
                        break
                    }
                }
                if (flag) return@withApplication CheckResult.wrong("Wrong meals list. The newly added meal is missing.")
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Wrong status code in /meals")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 12)
        fun getCategories(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/categories") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                val categories: List<Category> = Json.decodeFromString(response.content ?: "")
                var flag = true
                for (category in categories) {
                    if (category.categoryId == currentCategory.categoryId) {
                        flag = false
                        break
                    }
                }
                if (flag)
                    return@withApplication CheckResult.wrong("Wrong categories list. The newly added category is missing.")
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Wrong status code in /categories")
            }
            return@withApplication CheckResult.correct()
        }

    }
  learner_created: false
- name: src/presentation/routing/AuthRouting.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing

    import hotkitchen.domain.service.UserCredentialsService
    import hotkitchen.domain.service.tokenService.jwtToken.JwtTokenService
    import hotkitchen.presentation.routing.requestDto.SignInRequest
    import hotkitchen.presentation.routing.requestDto.SignUpRequest
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*
    import io.ktor.http.*
    import io.ktor.request.*
    import io.ktor.response.*
    import io.ktor.routing.*

    object AuthRouting {

        fun Routing.authRouting(userCredentialsService: UserCredentialsService, tokenService: JwtTokenService) {
            post("/signup") {
                val signupRequest = call.receive<SignUpRequest>()
                println("requestBody $signupRequest")

                val response = userCredentialsService.signUpUser(signupRequest)
                call.respond(HttpStatusCode.OK, response)
            }

            post("/signin") {
                val signinRequest = call.receive<SignInRequest>()
                println("requestBody $signinRequest")

                val response = userCredentialsService.signInUser(signinRequest)
                call.respond(HttpStatusCode.OK, response)
            }

            authenticate(tokenService.appScope) {
                get("/validate") {
                    println("headers ${call.request.headers}")

                    val principal: JWTPrincipal = call.principal<JWTPrincipal>()!!

                    val email = principal["email"]!!
                    val userType = principal["userType"]!!

                    call.respond(HttpStatusCode.OK, "Hello, $userType $email")
                }
            }
        }
    }
  learner_created: true
- name: src/presentation/routing/requestDto/SignUpRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import hotkitchen.domain.model.User
    import kotlinx.serialization.Serializable

    @Serializable
    data class SignUpRequest (
        val email: String,
        val userType: User.Type,
        val password: String,
    )
  learner_created: true
- name: src/presentation/routing/responseDto/SignupResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import kotlinx.serialization.SerialName
    import kotlinx.serialization.Serializable

    @Serializable
    data class SignupResponse(
        val status: Status
    ): ApiResponse {
        @Serializable
        enum class Status {
            @SerialName("Signed In") SIGNED_UP,
            @SerialName("Registration failed") REGISTRATION_FAILED,
            @SerialName("Invalid email") INVALID_EMAIL,
            @SerialName("Invalid password") INVALID_PASS,
            @SerialName("User already exists") DUPLICATED_USER
            ;
        }
    }
  learner_created: true
- name: src/util/Validation.kt
  visible: true
  text: |-
    package hotkitchen.util

    object Validation {

        fun String.isNotValidEmail(): Boolean {
            return "(\\w+[\\w.\\-])*\\w+@([A-Za-z0-9]+\\.)+[A-Za-z]{2,}".toRegex().matches(this).not()
        }

        fun String.isNotValidPass(): Boolean {
            return length < 6 || containsNoDigits() || containsNoLetter()
        }

        private fun String.containsNoDigits(): Boolean {
            return firstOrNull(Char::isDigit) == null
        }

        private fun String.containsNoLetter(): Boolean {
            return firstOrNull(Char::isLetter) == null
        }
    }
  learner_created: true
- name: src/presentation/routing/responseDto/SignInResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import kotlinx.serialization.SerialName
    import kotlinx.serialization.Serializable

    @Serializable
    data class SignInResponse (
        val status: Status
    ): ApiResponse {
        @Serializable
        enum class Status {
            @SerialName("Signed Up") SIGNED_IN,
            @SerialName("Authorization failed") AUTHORIZATION_FAILED,
            @SerialName("Invalid email or password") INVALID_SIGNIN,
            ;
        }
    }
  learner_created: true
- name: src/presentation/routing/responseDto/ApiResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    interface ApiResponse
  learner_created: true
- name: src/domain/exception/SignupExistingUserException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SignupExistingUserException(
        override val message: String = "There is already an user with that email registered"): Exception(message)
  learner_created: true
- name: src/data/repository/database/InMemoryUserCredentialsDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database

    import hotkitchen.domain.model.User

    object InMemoryUserCredentialsDatabase: UserCredentialsDatabase {

        private val database: MutableList<User> = mutableListOf()

        override fun userByEmail(email: String): User? {
            return database.firstOrNull { it.email == email }
        }

        override fun addUser(email: String, type: User.Type, password: String): User? {
            val user = User(email, type, password)
            database.add(user)
            return user
        }
    }
  learner_created: true
- name: src/Controller.kt
  visible: true
  text: |-
    package hotkitchen

    import hotkitchen.domain.service.UserInfoService
    import hotkitchen.domain.service.UserCredentialsService
    import hotkitchen.domain.service.tokenService.jwtToken.JwtTokenService
    import hotkitchen.presentation.routing.AuthRouting.authRouting
    import hotkitchen.presentation.routing.ErrorRouting.errorRouting
    import hotkitchen.presentation.routing.UserInfoRouting.userInfoRouting
    import hotkitchen.util.CustomLoggerPlugin
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.features.*
    import io.ktor.routing.*
    import io.ktor.serialization.*


    object Controller {
        fun Application.controller(userCredentialsService: UserCredentialsService, userInfoService: UserInfoService, tokenService: JwtTokenService, testing: Boolean) {

            install(ContentNegotiation) { json() }

            install(CustomLoggerPlugin)

            install(StatusPages){ errorRouting() }

            install(Authentication, tokenService.authConfig)

            install(Routing) {
    //        trace {
    //            //application.log.trace(it.buildText())
    //            println(it.buildText())
    //        }
                authRouting(userCredentialsService, tokenService)
                userInfoRouting(userInfoService, tokenService)
            }
        }
    }
  learner_created: true
- name: src/domain/model/UserInfo.kt
  visible: true
  text: |-
    package hotkitchen.domain.model

    import kotlinx.serialization.Serializable

    @Serializable
    data class UserInfo(
        val email: String,
        val type: User.Type,
        val name: String,
        val phone: String,
        val address: String
    )
  learner_created: true
- name: src/data/repository/database/UserCredentialsDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database

    import hotkitchen.domain.model.User

    interface UserCredentialsDatabase {
        fun userByEmail(email: String): User?
        fun addUser(email: String, type: User.Type, password: String): User?
    }
  learner_created: true
- name: src/presentation/routing/responseDto/UserInfoResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import hotkitchen.domain.model.User
    import hotkitchen.domain.model.UserInfo
    import kotlinx.serialization.Serializable

    @Serializable
    data class UserInfoResponse(
        val email: String,
        val userType: User.Type,
        val name: String,
        val phone: String,
        val address: String
    ): ApiResponse {
        companion object {
            fun fromUserInfo(userInfo: UserInfo): UserInfoResponse {
                return UserInfoResponse(
                    userInfo.email,
                    userInfo.type,
                    userInfo.name,
                    userInfo.phone,
                    userInfo.address
                )
            }
        }
    }
  learner_created: true
- name: src/domain/exception/SignupInvalidEmailException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SignupInvalidEmailException(
        override val message: String =
            "A valid email address consists of an email prefix and an email domain, both in acceptable formats. " +
                    "Use only letters, numbers, and special symbols:"
    ): Exception(message)
  learner_created: true
- name: src/domain/exception/SigninAuthorizationFail.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SigninAuthorizationFail(
        override val message: String = "Failed authorization"): Exception(message)
  learner_created: true
- name: src/domain/service/tokenService/TokenService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service.tokenService

    import hotkitchen.domain.model.User

    interface TokenService {

        fun isValidToken(tokenString: String): Boolean

        fun produceToken(userType: User.Type, email: String): String

        fun decodeToken(tokenString: String): Pair<String, String>
    }
  learner_created: true
- name: src/domain/exception/SignupInvalidPasswordException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class SignupInvalidPasswordException(
        override val message: String =
            "A valid password is a password that is at least six characters long and consists of letters and numbers"
    ): Exception(message)
  learner_created: true
- name: src/domain/exception/InvalidUpdateException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class InvalidUpdateException(
        override val message: String = "Invalid update"): Exception(message)
  learner_created: true
- name: src/data/repository/database/UserInfoDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database

    import hotkitchen.domain.model.UserInfo

    interface UserInfoDatabase {
        fun userInfoByEmail(email: String): UserInfo?
        fun updateOrCreateUserInfo(name: String, userType: String?, phone: String, email: String, address: String): UserInfo?
        fun deleteUser(email: String)
    }
  learner_created: true
- name: src/domain/exception/InvalidDeleteUserRequestException.kt
  visible: true
  text: |
    package hotkitchen.domain.exception

    class InvalidDeleteUserRequestException(
        override val message: String = "Invalid delete user request"): Exception(message)
  learner_created: true
- name: src/util/CustomLoggerPlugin.kt
  visible: true
  text: |-
    package hotkitchen.util

    import io.ktor.application.*
    import io.ktor.features.*
    import io.ktor.response.*
    import io.ktor.util.*

    class CustomLoggerPlugin {

        class Configuration

        companion object Plugin : ApplicationFeature<ApplicationCallPipeline, Configuration, CustomLoggerPlugin> {
            override val key = AttributeKey<CustomLoggerPlugin>("CustomLoggerPlugin")
            override fun install(pipeline: ApplicationCallPipeline, configure: Configuration.() -> Unit): CustomLoggerPlugin {
                val plugin = CustomLoggerPlugin()

                pipeline.intercept(ApplicationCallPipeline.Monitoring) { data ->
                    println("call: ${context.request.toLogString()}")
                    proceedWith(subject)
                }

                pipeline.sendPipeline.intercept(ApplicationSendPipeline.Transform) { data ->
                    val dataString = if(data is Unit) "" else ", $data"
                    println("response: ${call.response.status() ?: ""}$dataString")
                    proceedWith(subject)
                }

                return plugin
            }
        }
    }
  learner_created: true
- name: src/domain/service/tokenService/custom/CustomTokenService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service.tokenService.custom

    import hotkitchen.domain.model.User
    import hotkitchen.domain.service.tokenService.TokenService

    class CustomTokenService: TokenService {

        override fun isValidToken(tokenString: String): Boolean {
            return tokenString.startsWith("abc.")
        }

        override fun produceToken(userType: User.Type, email: String): String {
            return "abc.${userType.typeString}.${email.replace('.', '*')}"
        }

        override fun decodeToken(tokenString: String): Pair<String, String>{
            val (userType, email) = "^abc\\.(.*)\\.(.*)$".toRegex()
                .matchEntire(tokenString)!!.destructured
            return userType to email.replace('*', '.')
        }
    }
  learner_created: true
- name: src/domain/exception/DatabaseException.kt
  visible: true
  text: |
    package hotkitchen.domain.exception

    class DatabaseException(
        override val message: String = "Database failed") : Exception(message)
  learner_created: true
- name: src/data/repository/database/exposed/ExposedH2UserInfoDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import hotkitchen.data.repository.database.UserInfoDatabase
    import hotkitchen.domain.exception.InvalidDeleteUserRequestException
    import hotkitchen.domain.model.UserInfo
    import org.jetbrains.exposed.sql.Database
    import org.jetbrains.exposed.sql.insertAndGetId
    import org.jetbrains.exposed.sql.select
    import org.jetbrains.exposed.sql.transactions.transaction
    import org.jetbrains.exposed.sql.update

    class ExposedH2UserInfoDatabase(private val database: Database): UserInfoDatabase {
        override fun userInfoByEmail(email: String): UserInfo? {
            return transaction(database) {

                val query = UsersInfoTable.innerJoin(UsersTable).select {
                    UsersTable.email eq email
                }
                val userInfo = UserInfoEntity.wrapRows(query).firstOrNull()?.toUserInfo()

                userInfo
            }
        }

        override fun updateOrCreateUserInfo(
            name: String,
            userType: String?,
            phone: String,
            email: String,
            address: String
        ): UserInfo? {
            return transaction(database) {

                if(userType != null) {
                    UsersTable.update({ UsersTable.email eq email }) {
                        it[UsersTable.userType] = userType
                    }
                }

                val query = UsersInfoTable.innerJoin(UsersTable).select {
                    UsersTable.email eq email
                }
                val maybeUserInfoEntity = UserInfoEntity.wrapRows(query).firstOrNull()

                val userInfoId = if(maybeUserInfoEntity != null) {
                    UsersInfoTable.update({UsersInfoTable.id eq maybeUserInfoEntity.id}) {
                        it[this.name] = name
                        it[this.phone] = phone
                        it[this.address] = address
                    }
                    maybeUserInfoEntity.id
                } else {
                    val userEntity = UserEntity.find {
                        UsersTable.email eq email
                    }.firstOrNull()!!

                    UsersInfoTable.insertAndGetId {
                        it[this.address] = address
                        it[this.name] = name
                        it[this.user] = userEntity.id
                        it[this.phone] = phone
                    }
                }

                UserInfoEntity.find {
                    UsersInfoTable.id eq userInfoId
                }.firstOrNull()?.toUserInfo()
            }
        }

        override fun deleteUser(email: String) {
            return transaction(database) {



                val query = UsersInfoTable.innerJoin(UsersTable).select {
                    UsersTable.email eq email
                }
                val maybeUserInfoEntity = UserInfoEntity.wrapRows(query).firstOrNull() ?: throw InvalidDeleteUserRequestException()

                maybeUserInfoEntity.delete()
                maybeUserInfoEntity.user.delete()
            }
        }
    }
  learner_created: true
- name: src/domain/exception/InvalidUserInfoRequest.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class InvalidUserInfoRequest(
        override val message: String = "Invalid user info request"): Exception(message)
  learner_created: true
- name: src/domain/model/User.kt
  visible: true
  text: |
    package hotkitchen.domain.model

    import kotlinx.serialization.SerialName
    import kotlinx.serialization.Serializable
    import java.util.EnumSet

    @Serializable
    data class User (
        val email: String,
        val type: Type,
        val password: String,
    ) {
        @Serializable
        @Suppress("unused")
        enum class Type(val typeString: String) {
            @SerialName("staff") STAFF("staff"),
            @SerialName("testUser") TEST_USER("testUser"),
            @SerialName("client") CLIENT("client"),
            @SerialName("newType") NEW_TYPE("newType"),
            ;

            companion object {
                private val allValues = EnumSet.allOf(User.Type::class.java)

                fun fromTypeString(typeString: String): User.Type? {
                    return allValues.firstOrNull { it.typeString == typeString }
                }
            }
        }
    }
  learner_created: true
- name: src/data/repository/UserCredentialsRepository.kt
  visible: true
  text: |-
    package hotkitchen.data.repository

    import hotkitchen.domain.exception.SignupExistingUserException
    import hotkitchen.domain.exception.DatabaseException
    import hotkitchen.data.repository.database.UserCredentialsDatabase
    import hotkitchen.domain.model.User

    class UserCredentialsRepository(private val userCredentialsDatabase: UserCredentialsDatabase) {

        fun addUser(email: String, type: User.Type, password: String): User {
            val maybeUser = userCredentialsDatabase.userByEmail(email)

            if(maybeUser != null) {
                throw SignupExistingUserException("There is already an user with ${email} registered")
            }

            val maybeUserAdded = userCredentialsDatabase.addUser(email, type, password)

            return maybeUserAdded ?: throw DatabaseException()
        }

        fun getUser(email: String): User? {
            return userCredentialsDatabase.userByEmail(email)
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/ExposedH2UserCredentialsDatabase.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import hotkitchen.data.repository.database.UserCredentialsDatabase
    import hotkitchen.domain.model.User
    import org.jetbrains.exposed.sql.Database
    import org.jetbrains.exposed.sql.transactions.transaction

    class ExposedH2UserCredentialsDatabase(private val database: Database): UserCredentialsDatabase {
        override fun userByEmail(email: String): User? {
            return transaction(database) {
                UserEntity.find {
                    UsersTable.email eq email
                }.firstOrNull()
                    ?.toUser()
            }
        }

        override fun addUser(email: String, type: User.Type, password: String): User? {
            return try {
                transaction(database) {
                    UserEntity.new {
                        this.email = email
                        this.userType = type.name
                        this.password = password
                    }
                }.toUser()
            } catch (e: Exception) {
                null
            }
        }
    }
  learner_created: true
- name: src/domain/exception/UnauthorizedAccessException.kt
  visible: true
  text: |-
    package hotkitchen.domain.exception

    class UnauthorizedAccessException(
        override val message: String = "Unauthorized Access"): Exception(message)
  learner_created: true
- name: src/presentation/routing/ErrorRouting.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing

    import hotkitchen.domain.exception.*
    import hotkitchen.presentation.routing.responseDto.SignInResponse
    import hotkitchen.presentation.routing.responseDto.SignInResponse.Status.INVALID_SIGNIN
    import hotkitchen.presentation.routing.responseDto.SignupResponse
    import hotkitchen.presentation.routing.responseDto.SignupResponse.Status.*
    import io.ktor.application.*
    import io.ktor.features.*
    import io.ktor.http.*
    import io.ktor.response.*

    object ErrorRouting {
        fun StatusPages.Configuration.errorRouting() {

            exception<SignupExistingUserException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignupResponse(DUPLICATED_USER))
            }

            exception<SignupInvalidEmailException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignupResponse(INVALID_EMAIL))
            }

            exception<SignupInvalidPasswordException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignupResponse(INVALID_PASS))
            }

            exception<DatabaseException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.InternalServerError, mapOf("error" to cause.localizedMessage))
            }

            exception<SigninAuthorizationFail> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Forbidden, SignInResponse(INVALID_SIGNIN))
            }

            exception<UnauthorizedAccessException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.Unauthorized, HttpStatusCode.Unauthorized)
            }

            exception<InvalidUpdateException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.BadRequest, HttpStatusCode.BadRequest)
            }

            exception<InvalidUserInfoRequest> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.BadRequest, HttpStatusCode.BadRequest)
            }

            exception<InvalidDeleteUserRequestException> { cause ->
                logException(cause)
                call.respond(HttpStatusCode.BadRequest, HttpStatusCode.BadRequest)
            }
        }

        private fun logException(cause: Exception) {
            println("Exception: ${cause.localizedMessage}")
            //cause.printStackTrace()
        }
    }
  learner_created: true
- name: src/presentation/routing/responseDto/TokenResponse.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.responseDto

    import kotlinx.serialization.Serializable

    @Serializable
    data class TokenResponse(val token: String = "abc.def.***") : ApiResponse
  learner_created: true
- name: src/domain/service/UserInfoService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service

    import hotkitchen.data.repository.UserInfoRepository
    import hotkitchen.domain.exception.DatabaseException
    import hotkitchen.domain.exception.InvalidUpdateException
    import hotkitchen.domain.exception.InvalidUserInfoRequest
    import hotkitchen.domain.model.User
    import hotkitchen.presentation.routing.requestDto.UserInfoUpdateRequest
    import hotkitchen.presentation.routing.responseDto.ApiResponse
    import hotkitchen.presentation.routing.responseDto.UserInfoResponse

    class UserInfoService(private val userInfoRepository: UserInfoRepository) {

        fun getUserInfo(email: String): ApiResponse {

            return UserInfoResponse.fromUserInfo(
                userInfoRepository.getUserInfoByMail(email) ?: throw InvalidUserInfoRequest()
            )
        }

        fun updateUserInfo(email: String, userType: User.Type, userInfoUpdateRequest: UserInfoUpdateRequest): ApiResponse {

            if(email !=  userInfoUpdateRequest.email) {
                throw InvalidUpdateException("Invalid update for user info, email cannot be changed")
            }

            val (name, requestUserType, phone, requestEmail, address) = userInfoUpdateRequest

            val userInfo = if(userType != requestUserType) {
                userInfoRepository.updateOrCreateUserInfo(name, requestUserType.name, phone, requestEmail, address)
            } else {
                userInfoRepository.updateOrCreateUserInfo(name, phone, requestEmail, address)
            } ?: throw DatabaseException()

            return UserInfoResponse.fromUserInfo(userInfo)
        }

        fun deleteUser(email: String) {
            userInfoRepository.deleteUser(email)
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/ExposedDatabaseConnection.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import org.jetbrains.exposed.sql.*
    import org.jetbrains.exposed.sql.transactions.transaction

    class ExposedDatabaseConnection(private vararg val tables: Table) {
        val database = Database.connect("jdbc:h2:mem:regular;DB_CLOSE_DELAY=-1;", "org.h2.Driver")

        init {
            transaction(database) {
                tables.forEach {
                    SchemaUtils.create(it)
                }
                addLogger(StdOutSqlLogger)
            }
        }
    }
  learner_created: true
- name: src/data/repository/UserInfoRepository.kt
  visible: true
  text: |-
    package hotkitchen.data.repository

    import hotkitchen.data.repository.database.UserInfoDatabase
    import hotkitchen.domain.exception.InvalidDeleteUserRequestException
    import hotkitchen.domain.model.UserInfo

    class UserInfoRepository(private val userInfoDatabase: UserInfoDatabase) {



        fun getUserInfoByMail(email : String): UserInfo? {
            return userInfoDatabase.userInfoByEmail(email)
        }

        fun updateOrCreateUserInfo(name: String, phone: String, email: String, address: String): UserInfo? {
            return userInfoDatabase.updateOrCreateUserInfo(name, null, phone, email, address)
        }

        fun updateOrCreateUserInfo(name: String, userType: String, phone: String, email: String, address: String): UserInfo? {
            return userInfoDatabase.updateOrCreateUserInfo(name, userType, phone, email, address)
        }

        fun deleteUser(email: String) {
            userInfoDatabase.deleteUser(email)

        }
    }
  learner_created: true
- name: src/domain/service/UserCredentialsService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service

    import hotkitchen.domain.exception.SigninAuthorizationFail
    import hotkitchen.domain.exception.SignupInvalidEmailException
    import hotkitchen.domain.exception.SignupInvalidPasswordException
    import hotkitchen.presentation.routing.requestDto.SignInRequest
    import hotkitchen.presentation.routing.requestDto.SignUpRequest
    import hotkitchen.presentation.routing.responseDto.ApiResponse
    import hotkitchen.presentation.routing.responseDto.TokenResponse
    import hotkitchen.data.repository.UserCredentialsRepository
    import hotkitchen.domain.service.tokenService.TokenService
    import hotkitchen.util.Validation.isNotValidEmail
    import hotkitchen.util.Validation.isNotValidPass

    class UserCredentialsService(private val userCredentialsRepository: UserCredentialsRepository, private val tokenService: TokenService) {

        fun signInUser(signInRequest: SignInRequest): ApiResponse {
            val maybeUser = userCredentialsRepository.getUser(signInRequest.email)

            return if (maybeUser?.password != signInRequest.password) {
                throw SigninAuthorizationFail()
            } else {
                TokenResponse(tokenService.produceToken(maybeUser.type, maybeUser.email))
            }
        }

        fun signUpUser(signUpRequest: SignUpRequest): ApiResponse {
            val (email, type, password) = signUpRequest

            if(email.isNotValidEmail()) {
                throw SignupInvalidEmailException()
            } else if(password.isNotValidPass()) {
                throw SignupInvalidPasswordException()
            }

            userCredentialsRepository.addUser(email, type, password)
            return TokenResponse(tokenService.produceToken(type, email))
        }
    }
  learner_created: true
- name: src/domain/service/tokenService/jwtToken/JwtTokenService.kt
  visible: true
  text: |-
    package hotkitchen.domain.service.tokenService.jwtToken

    import com.auth0.jwt.JWT
    import com.auth0.jwt.algorithms.Algorithm
    import hotkitchen.domain.exception.UnauthorizedAccessException
    import hotkitchen.domain.model.User
    import hotkitchen.domain.service.tokenService.TokenService
    import hotkitchen.util.Validation.isNotValidEmail
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*
    import java.util.*

    class JwtTokenService(environment: ApplicationEnvironment): TokenService {

        private val secret = environment.config.property("jwt.secret").getString()
        private val issuer = environment.config.property("jwt.issuer").getString()
        private val audience = environment.config.property("jwt.audience").getString()
        private val expirationTime = 1000 * 60 * 10
        private val algorithm = Algorithm.HMAC256(secret)

        private val realm = environment.config.property("jwt.realm").getString()
        private val jwtVerifier = JWT.require(algorithm)
            .withAudience(audience)
            .withIssuer(issuer)
            .withClaimPresence("email")
            .withClaimPresence("userType")
            .build()
        val appScope = "appScope"

        val authConfig: Authentication.Configuration.() -> Unit = {
            jwt(appScope) {
                realm = this@JwtTokenService.realm
                verifier(jwtVerifier)

                validate { credential ->
                    val payload = credential.payload
                    val email = payload.getClaim("email").asString()
                    if(email.isNotValidEmail()) {
                        null
                    } else {
                        JWTPrincipal(payload)
                    }
                }

                challenge { _, _ ->
                    throw UnauthorizedAccessException()
                }
            }
        }

        override fun isValidToken(tokenString: String): Boolean {

            return try {
                jwtVerifier.verify(tokenString)
                true
            } catch (e: Exception) {
                false
            }
        }

        override fun produceToken(userType: User.Type, email: String): String {
            return JWT.create()
                .withAudience(audience)
                .withIssuer(issuer)
                .withClaim("email", email)
                .withClaim("userType", userType.typeString)
                .withExpiresAt(Date(System.currentTimeMillis() + expirationTime))
                .sign(algorithm)
        }

        override fun decodeToken(tokenString: String): Pair<String, String> {
            val jwt = JWT.decode(tokenString)
            val email = jwt.getClaim("email").asString()
            val userType = jwt.getClaim("userType").asString()

            return userType to email
        }
    }
  learner_created: true
- name: src/presentation/routing/UserInfoRouting.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing

    import hotkitchen.domain.model.User
    import hotkitchen.domain.service.UserInfoService
    import hotkitchen.domain.service.tokenService.jwtToken.JwtTokenService
    import hotkitchen.presentation.routing.requestDto.UserInfoUpdateRequest
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*
    import io.ktor.http.*
    import io.ktor.request.*
    import io.ktor.response.*
    import io.ktor.routing.*

    object UserInfoRouting {

        fun Routing.userInfoRouting(userInfoService: UserInfoService, tokenService: JwtTokenService) {
            authenticate(tokenService.appScope) {
                get("/me")  {
                    println("headers ${call.request.headers}")
                    val (email, ) = call.getClaims("email")
                    val userInfo = userInfoService.getUserInfo(email)
                    println("email: $email")

                    call.respond(HttpStatusCode.OK, userInfo)
                }

                put("/me") {
                    println("headers ${call.request.headers}")
                    val userInfoUpdateRequest = call.receive<UserInfoUpdateRequest>()
                    println("requestBody $userInfoUpdateRequest")
                    val (email, userTypeStr) = call.getClaims("email", "userType")
                    println("email: $email, userType: $userTypeStr")

                    val response = userInfoService.updateUserInfo(email, User.Type.fromTypeString(userTypeStr)!!, userInfoUpdateRequest)

                    call.respond(HttpStatusCode.OK, response)
                }

                delete("/me") {
                    println("headers ${call.request.headers}")
                    val (email, ) = call.getClaims("email")
                    println("email: $email")

                    userInfoService.deleteUser(email)

                    call.respond(HttpStatusCode.OK, HttpStatusCode.OK)
                }
            }
        }

        private fun ApplicationCall.getClaims(vararg name: String): List<String> {
            val jwtPrincipal = this.principal<JWTPrincipal>()!!

            return name.map {
                jwtPrincipal[it]!!
            }
        }
    }
  learner_created: true
- name: src/presentation/routing/requestDto/UserInfoUpdateRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import hotkitchen.domain.model.User
    import kotlinx.serialization.Serializable


    @Serializable
    data class UserInfoUpdateRequest (
        val name: String,
        val userType: User.Type,
        val phone: String,
        val email: String,
        val address: String,
    )
  learner_created: true
- name: src/presentation/routing/requestDto/SignInRequest.kt
  visible: true
  text: |-
    package hotkitchen.presentation.routing.requestDto

    import kotlinx.serialization.Serializable

    @Serializable
    data class SignInRequest (
        val email: String,
        val password: String,
    )
  learner_created: true
- name: src/presentation/routing/MealRouting.kt
  visible: true
  learner_created: true
- name: src/domain/exception/DeniedAccessException.kt
  visible: true
  learner_created: true
- name: src/domain/service/MealService.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/requestDto/AddMealRequest.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/SimpleStatusResponse.kt
  visible: true
  learner_created: true
- name: src/data/repository/MealRepository.kt
  visible: true
  learner_created: true
- name: src/domain/model/Meal.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/AddMealResponse.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/MealDatabase.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/entity/CategoryEntity.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/entity/MealEntity.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/entity/UserInfoEntity.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import hotkitchen.domain.model.User
    import hotkitchen.domain.model.UserInfo
    import org.jetbrains.exposed.dao.IntEntity
    import org.jetbrains.exposed.dao.IntEntityClass
    import org.jetbrains.exposed.dao.id.EntityID

    class UserInfoEntity(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<UserInfoEntity>(UsersInfoTable)

        var name: String by UsersInfoTable.name
        var phone: String by UsersInfoTable.phone
        var address: String by UsersInfoTable.address
        var user: UserEntity by UserEntity referencedOn UsersInfoTable.user


        fun toUserInfo(): UserInfo {
            return UserInfo(user.email, User.Type.valueOf(user.userType), name, phone, address)
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/entity/UserCredentialsEntity.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import hotkitchen.domain.model.User
    import org.jetbrains.exposed.dao.IntEntity
    import org.jetbrains.exposed.dao.IntEntityClass
    import org.jetbrains.exposed.dao.id.EntityID

    class UserEntity(id: EntityID<Int>) : IntEntity(id) {
        companion object : IntEntityClass<UserEntity>(UsersTable)

        var email: String by UsersTable.email
        var password: String by UsersTable.password
        var userType: String by UsersTable.userType

        fun toUser(): User {
            return User(email, User.Type.valueOf(userType), password)
        }
    }
  learner_created: true
- name: src/data/repository/database/exposed/table/CategoryTable.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/table/MealTable.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/table/MealToCategoryRelationTable.kt
  visible: true
  learner_created: true
- name: src/data/repository/database/exposed/table/UserCredentialsTable.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import org.jetbrains.exposed.dao.id.IntIdTable
    import org.jetbrains.exposed.sql.Column

    object UsersTable : IntIdTable() {
        val email: Column<String> = varchar("email", 100).uniqueIndex()
        val password: Column<String> = varchar("password", 100)
        val userType: Column<String> = varchar("user_type", 50)
    }
  learner_created: true
- name: src/data/repository/database/exposed/table/UserInfoTable.kt
  visible: true
  text: |-
    package hotkitchen.data.repository.database.exposed

    import org.jetbrains.exposed.dao.id.EntityID
    import org.jetbrains.exposed.dao.id.IntIdTable
    import org.jetbrains.exposed.sql.Column

    object UsersInfoTable : IntIdTable()  {
        val name: Column<String> = varchar("name", 100)
        val phone: Column<String> = varchar("phone", 20)
        val address: Column<String> = varchar("address", 300)
        val user: Column<EntityID<Int>> = reference("user", UsersTable).uniqueIndex()
    }
  learner_created: true
- name: src/data/repository/database/exposed/ExposedH2MealDatabase.kt
  visible: true
  learner_created: true
- name: src/domain/exception/DuplicateMealException.kt
  visible: true
  learner_created: true
- name: src/domain/model/Category.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/requestDto/AddCategoryRequest.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/AddCategoryResponse.kt
  visible: true
  learner_created: true
- name: src/util/Extensions.kt
  visible: true
  learner_created: true
- name: src/domain/exception/DuplicateCategoryException.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/GetMealResponse.kt
  visible: true
  learner_created: true
- name: src/domain/exception/InvalidMealIdException.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/GetCategoryResponse.kt
  visible: true
  learner_created: true
- name: src/domain/exception/InvalidCategoryIdException.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/GetAllMealResponse.kt
  visible: true
  learner_created: true
- name: src/presentation/routing/responseDto/GetAllCategoryResponse.kt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/22606#comment
status: Solved
feedback:
  message: Congratulations!
  time: Tue, 01 Nov 2022 06:52:36 UTC
record: 4
